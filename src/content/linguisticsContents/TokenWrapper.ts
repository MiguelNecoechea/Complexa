/**
 * Core utility responsible for inserting visual markup (<span class="lingua-token">)
 * around Japanese tokens that have already been segmented on the backend side.
 *
 * 1. The caller passes an ordered list of `Paragraph` objects and the parallel
 *    `Token[][]` (same length, one token array per paragraph).
 *
 * 2. `wrap()` iterates paragraph‑by‑paragraph, and inside each paragraph walks
 *    **every** DOM `Text` node (already collected by the extractor).
 *
 * 3. For each `Text` node we invoke `wrapTextNode()` which performs a sliding‑
 *    window scan, copying plain substrings and wrapping matching tokens with
 *    a <span> generated by `buildSpan()`.
 *
 * 4. We batch DOM mutations in a `DocumentFragment` and finally swap the
 *    original `Text` node with the fragment via `replaceChild()` – one reflow
 *    per node instead of per token (see MDN on `DocumentFragment`).
 *
 * 5. All <span> references are returned to the caller as a 2‑D matrix so that
 *    higher‑level UI code (colouring, tooltip positioning, etc.) can work with
 *    them later.
 */

import { Paragraph } from "../../models/Paragraph";
import { Token } from "../../models/JapaneseTokens";
import { SettingsService } from "../../services/SettingsService";
import HoverTokenView from "../../views/HoverTokenView";

export class TokenWrapper {
    private tooltipReady: boolean = false;
    private hoverEnabled: boolean = false;

    /**
     * Public entry point – wrap the whole page (or selection).
     *
     * @param paragraphs      Ordered list of `Paragraph`s returned by the
     *                        extraction phase.  Each paragraph exposes its
     *                        original container element and an *ordered* array
     *                        of `Text` nodes (`textNodes`).
     * @param tokenizedArrays A parallel array where `tokenizedArrays[i]` holds
     *                        the tokens for `paragraphs[i]`.
     * @param hoverEnabled    Tells if the hover is enabled.
     * @returns               2‑D matrix: one row per paragraph, each containing
     *                        the <span> elements we created for that paragraph.
     */
    public async wrap(paragraphs: Paragraph[], tokenizedArrays: Token[][],
               hoverEnabled: boolean): Promise<HTMLElement[][]> {
        const matrix: HTMLElement[][] = [];
        let tokIdx: number = 0;
        let paraOffset: number = 0;
        let spillover: number = 0;
        this.hoverEnabled = hoverEnabled;

        for (let pIdx: number = 0; pIdx < paragraphs.length; pIdx++) {
            const paragraph: Paragraph = paragraphs[pIdx];
            const tokens: Token[] = tokenizedArrays[pIdx] ?? [];
            const row: HTMLElement[] = [];

            if (!tokens.length) {
                matrix.push(row);
                continue;
            }

            tokIdx = 0;
            paraOffset = 0;
            spillover = 0;
            for (const node of paragraph.textNodes) {
                if (spillover >= node.data.length) {
                    paraOffset += node.data.length;
                    spillover -= node.data.length;
                    node.parentNode!.replaceChild(node.ownerDocument!.createDocumentFragment(), node);
                    continue;
                }
                const skip: number = spillover;
                const { fragment, consumed, spill } = await this.wrapTextNode(node, tokens, tokIdx, paraOffset + skip, row, skip);
                node.parentNode!.replaceChild(fragment, node);
                tokIdx += consumed;
                paraOffset += node.data.length;
                spillover = spill;
            }
            matrix.push(row);
        }

        if (this.hoverEnabled) await this.mountHoverToolTip();
        return matrix;
    }

    public async setHoverEnabled(enable: boolean): Promise<void> {
        this.hoverEnabled = enable;
        if (this.hoverEnabled) await this.mountHoverToolTip();
    }


    /**
     * Walk a single Text node from left→right, emit plain text + wrapped tokens,
     * and return how many tokens we consumed.
     *
     * @param node        The `Text` DOM node we’re processing.
     * @param tokens      Full token array for the paragraph.
     * @param startIdx    Index of the first *unwrapped* token.
     * @param paraOffset  Absolute paragraph offset of the first unconsumed character in this node.
     * @param row         Collects <span> references for caller.
     * @param skip        Number of leading characters already consumed by a previous token.
     */
    private async wrapTextNode(node: Text, tokens: Token[], startIdx: number, paraOffset: number, row: HTMLElement[],
                        skip: number = 0): Promise<{ fragment: DocumentFragment; consumed: number; spill: number }> {
        const frag: DocumentFragment = node.ownerDocument!.createDocumentFragment();
        const text: string = node.data.slice(skip);
        const nodeEnd: number = paraOffset + text.length;

        let localPos: number = 0;
        let idx: number = startIdx;
        let spill: number = 0;

        while (idx < tokens.length && tokens[idx].offset < nodeEnd) {
            const tok: Token = tokens[idx];
            const relStart: number = tok.offset - paraOffset;

            if (tok.offset < paraOffset + localPos) {
                idx++;
                continue;
            }

            if (relStart > localPos) frag.append(node.ownerDocument!.createTextNode(text.slice(localPos, relStart)));
            const hoverStatus: boolean = await SettingsService.getSetting("enableHover");
            const hoverStatusStr: string = hoverStatus.toString();
            const span: HTMLSpanElement = this.buildSpan(tok, hoverStatusStr);
            frag.append(span);
            row.push(span);

            localPos = relStart + tok.surface.length;
            const tokEnd: number = tok.offset + tok.surface.length;
            if (tokEnd > nodeEnd) spill = tokEnd - nodeEnd;
            idx++;
        }

        if (localPos < text.length) frag.append(node.ownerDocument!.createTextNode(text.slice(localPos)));

        return { fragment: frag, consumed: idx - startIdx, spill };
    }

    /**
     * @private
     * Construct a <span> element populated with linguistic metadata so that the
     * hover UI and other modules can query it later.
     *
     * @param tok Token metadata from the backend (surface, reading, pos, ...).
     * @param hoverStatus the status to tell the frontend if the hover should be rendered.
     */
    private buildSpan(tok: Token, hoverStatus: string): HTMLSpanElement {
        const span: HTMLSpanElement = document.createElement("span");
        span.textContent = tok.surface;
        span.classList.add("lingua-token", "mw-no-invert", "notheme");

        span.dataset.surface = tok.surface;
        span.dataset.pos = tok.pos;
        span.dataset.lemma = tok.lemma;
        span.dataset.tag = tok.tag;
        span.dataset.dep = tok.dep;
        span.dataset.head = String(tok.head);
        span.dataset.offset = String(tok.offset);
        span.dataset.ent_obj = tok.ent_iob;
        span.dataset.ent_type = tok.ent_type;
        span.dataset.is_japanese = tok.is_japanese;
        span.dataset.hoverEnabled = hoverStatus;
        if (tok.reading) span.dataset.reading = tok.reading;
        return span;
    }

    /**
     * @private
     * Lazily inject the shared hover tooltip into the document exactly once.
     */
    private async mountHoverToolTip(): Promise<void> {
        if (this.tooltipReady) return;

        const hoverHTML: string = await fetch(chrome.runtime.getURL("static/views/hoverView.html"))
            .then((r: Response): Promise<string> => r.text());

        document.body.insertAdjacentHTML("beforeend", hoverHTML);
        new HoverTokenView();
        this.tooltipReady = true;
    }


}
